# 股票代码二次检查机制

**任务 ID**: T018
**优先级**: P0
**创建时间**: 2026-02-02 23:40
**状态**: 待开发

**问题**: 2026-02-02 画星环科技时使用了错误代码 (688337 → 688031 → 正确是 688011)

---

## 问题描述

### 错误场景
- 用户要求: 星环科技分时图
- 系统操作: 使用 akshare 获取错误股票数据
- 实际结果: 画的是错误的股票
- **正确代码**: 688011 (从 opus_experts 记录中找到)

### 错误历史
| 时间 | 使用代码 | 状态 |
|------|----------|------|
| 第一次 | 688337 | ❌ 错误 |
| 第二次 | 688031 | ❌ 错误 |
| **第三次** | **688011** | ✅ **正确** |

### 影响
- 生成的图表和数据完全错误
- 用户信任度下降
- 需要返工

---

## 已确认的股票代码

```yaml
# 股票代码缓存 (已验证)

# 科创板
星环科技: 688011

# 其他常用股票
保变电气: 600550
比亚迪: 002594
# ...更多股票
```

---

## 解决方案

### 方案 1: 股票代码验证 API

在获取股票数据前，调用验证接口确认代码正确性：

```python
def validate_stock_code(ts_code: str, stock_name: str) -> bool:
    """
    验证股票代码和名称是否匹配
    
    Args:
        ts_code: 股票代码 (如 688031)
        stock_name: 股票名称 (如 星环科技)
    
    Returns:
        True: 匹配
        False: 不匹配
    """
    # 调用 akshare 接口验证
    info = ak.stock_info_a_code_name()
    matched = info[info['code'] == ts_code]['name'].values
    
    if len(matched) == 0:
        return False
    
    return matched[0] == stock_name
```

### 方案 2: 本地股票代码缓存

建立本地股票代码缓存，避免每次都查询：

```python
# stock_code_cache.yaml
STOCK_CODES:
  星环科技: 688031
  保变电气: 600550
  比亚迪: 002594
  # ...更多股票

def get_stock_code(stock_name: str) -> str:
    """根据股票名称获取代码"""
    return STOCK_CODES.get(stock_name, None)
```

### 方案 3: 多数据源交叉验证

同时查询多个数据源，确认结果一致：

```python
def cross_validate(ts_code: str):
    """交叉验证股票信息"""
    # akshare
    ak_info = ak.stock_info_a_code_name()
    ak_name = ak_info[ak_info['code'] == ts_code]['name'].values[0]
    
    # Eastmoney API
    em_response = requests.get(f"https://quote.eastmoney.com/{ts_code}.html")
    
    # 对比结果
    return ak_name == expected_name
```

---

## 开发清单

### 阶段 1: 基础验证 (2 小时)

- [ ] 1.1 创建股票代码缓存 `stock_codes.yaml`
- [ ] 1.2 实现 `validate_stock_code()` 函数
- [ ] 1.3 添加单元测试

### 阶段 2: 集成到现有流程 (1 小时)

- [ ] 2.1 修改 `chart_analyzer.py` 添加验证
- [ ] 2.2 修改 `technical_detector.py` 添加验证
- [ ] 2.3 添加错误提示

### 阶段 3: 增强功能 (2 小时)

- [ ] 3.1 支持模糊匹配（容错）
- [ ] 3.2 支持多数据源验证
- [ ] 3.3 自动更新缓存

---

## API 设计

### 核心函数

```python
class StockValidator:
    """股票代码验证器"""
    
    def __init__(self, cache_file: str = "stock_codes.yaml"):
        self.cache = self._load_cache(cache_file)
    
    def validate(self, ts_code: str, expected_name: str) -> ValidationResult:
        """
        验证股票代码
        
        Returns:
            ValidationResult:
                - is_valid: bool
                - actual_name: str
                - confidence: float
                - suggestion: str
        """
        pass
    
    def get_code_by_name(self, name: str) -> Optional[str]:
        """根据名称获取代码"""
        pass
    
    def get_name_by_code(self, code: str) -> Optional[str]:
        """根据代码获取名称"""
        pass
```

### 使用示例

```python
validator = StockValidator()

# 验证
result = validator.validate("688031", "星环科技")

if not result.is_valid:
    print(f"❌ 验证失败!")
    print(f"  期望: 星环科技")
    print(f"  实际: {result.actual_name}")
    print(f"  建议: {result.suggestion}")
else:
    print(f"✅ 验证通过: {result.actual_name}")
```

---

## 验收标准

- [ ] 能够识别错误的股票代码
- [ ] 验证准确率 > 99%
- [ ] 验证延迟 < 1 秒
- [ ] 集成到所有需要股票代码的模块

---

## 预估工时

**总计: 5 小时**

---

## 相关文件

- `src/analyzer/chart_analyzer.py` - 需要集成验证
- `src/detector/technical_detector.py` - 需要集成验证
- `docs/PLAN_03_chart_analyzer.md` - 需要添加验证要求

---

*最后更新: 2026-02-02 23:40*
